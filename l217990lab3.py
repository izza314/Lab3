# -*- coding: utf-8 -*-
"""l217990lab3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vv5qFzLyYEmJMzbZ05rfAWFoCpQexgVe
"""

#q1
from collections import deque

def find_shortest_path(matrix):
    # Directions: Up, Down, Left, Right
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    # Initialize starting and ending positions (adjusting to 0-based indexing)
    start = (0, 0)
    end = (3, 3)
    rows = len(matrix)
    cols = len(matrix[0])

    # Initialize data structures for BFS
    queue = deque([(start, [start])]) # Use deque for BFS
    visited = {start}  # Track visited positions

    # BFS Loop
    while queue:
        (row, col), path = queue.popleft()

        # Check if HOME is reached
        if (row, col) == end:
            return path

        # Explore neighboring cells (non-diagonal and not obstacles)
        for dr, dc in directions:
            new_row, new_col = row + dr, col + dc

            # Check boundaries and obstacles
            if 0 <= new_row < rows and 0 <= new_col < cols and matrix[new_row][new_col] == 0 and (new_row, new_col) not in visited:
                new_position = (new_row, new_col)
                new_path = path + [new_position]
                queue.append((new_position, new_path))
                visited.add(new_position)

    # Return None if no path is found
    return None

# 0 represents open path and other number represents obstacles

matrix = [
    [0, 0, 0, 0, 0, 0],
    [0, 0, 1, 1, 0, 0],
    [0, 0, 0, 1, 1, 0],
    [0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0]
]

shortest_path = find_shortest_path(matrix)

if shortest_path:
    print("Shortest Path:", shortest_path)
else:
    print("No path found.")

#q2
import time

def state_to_tuple(state):
    """Convert a string state to a tuple representation."""
    return tuple([tuple(state[i:i+3]) for i in range(0, 9, 3)])

def tuple_to_state(matrix):
    """Convert a tuple representation back to a string state."""
    return ''.join([''.join(row) for row in matrix])

def get_moves(matrix):
    """Generate possible moves from the given state."""
    moves = []
    # Find the blank space (0)
    for i, row in enumerate(matrix):
        if '0' in row:
            x, y = i, row.index('0')
            break

    # Define possible moves: Up, Down, Left, Right
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    for dx, dy in directions:
        new_x, new_y = x + dx, y + dy

        # Check if the new position is within bounds
        if 0 <= new_x < 3 and 0 <= new_y < 3:
            # Swap the blank space with the adjacent tile
            new_matrix = [list(row) for row in matrix]
            new_matrix[x][y], new_matrix[new_x][new_y] = new_matrix[new_x][new_y], new_matrix[x][y]
            moves.append(tuple([tuple(row) for row in new_matrix]))

    return moves

def dfs(start_state, goal_state):
    """Perform Depth-First Search (DFS) to find a solution path."""
    stack = [(start_state, [])]  # Store state and path to reach it
    visited = set()

    while stack:
        state, path = stack.pop()

        # Check if the goal state is reached
        if state == goal_state:
            return path

        visited.add(state)

        # Explore possible moves
        for move in get_moves(state):
            if move not in visited:
                stack.append((move, path + [move]))

    # Return None if no solution is found
    return None

def main():
    """Main function to take input and execute the DFS algorithm."""
    start_state = input("Enter start State: ")
    goal_state = input("Enter goal State: ")
    start_tuple = state_to_tuple(start_state)
    goal_tuple = state_to_tuple(goal_state)
    print("-----------------")
    print("DFS Algorithm")
    print("-----------------")
    start_time = time.time()
    solution_path = dfs(start_tuple, goal_tuple)
    end_time = time.time()

    if solution_path:
        print("Time taken:", end_time - start_time, "seconds")
        print("Path Cost:", len(solution_path))
        print("No of Nodes Visited:", len(solution_path) + 1)
        for state in solution_path:
            for row in state:
                print(' '.join(row))
            print("-----")
    else:
        print("No solution found.")

if __name__ == "__main__":
    main()



#q3
from collections import deque

class Graph:
    def __init__(self, adjacency_list):
        """Initializes the graph with an adjacency list."""
        self.adjacency_list = adjacency_list

    def get_neighbors(self, v):
        """Returns the neighbors of a given node."""
        return self.adjacency_list[v]

    def h(self, n):
        """Heuristic function: estimates the cost from node n to the goal."""
        H = {
            'The': 4,
            'Cat': 3,
            'Dog': 3,
            'runs': 2,
            'fast': 1
        }
        return H[n]

    def a_star_algorithm(self, start_node, stop_node):
        """Implements the A* search algorithm to find the optimal path."""
        open_list = set([start_node])
        closed_list = set([])
        g = {}  # Cost from start node to all other nodes
        g[start_node] = 0
        parents = {}  # Keeps track of paths
        parents[start_node] = start_node

        while len(open_list) > 0:
            n = None

            # Find the node with the lowest f(n) = g(n) + h(n)
            for v in open_list:
                if n == None or g[v] + self.h(v) < g[n] + self.h(n):
                    n = v

            if n == None:
                print("Path does not exist!")
                return None

            # If the goal node is found, reconstruct and return the path
            if n == stop_node:
                reconst_path = []
                while parents[n] != n:
                    reconst_path.append(n)
                    n = parents[n]
                reconst_path.append(start_node)
                reconst_path.reverse()

                print("Sentence:", ' '.join(reconst_path))
                print("Total cost:", g[stop_node])
                return reconst_path

            # Explore all neighbors of the current node
            for (m, weight) in self.get_neighbors(n):
                # If the neighbor node is not in open or closed list, add it
                if m not in open_list and m not in closed_list:
                    open_list.add(m)
                    parents[m] = n
                    g[m] = g[n] + weight
                else:
                    # If the new path is cheaper, update the cost and parent
                    if g[m] > g[n] + weight:
                        g[m] = g[n] + weight
                        parents[m] = n

                        if m in closed_list:
                            closed_list.remove(m)
                            open_list.add(m)

            open_list.remove(n)
            closed_list.add(n)

        print("Path does not exist!")
        return None

# Define the graph given in adjacency list
adjacency_list = {
    'The': [('Cat', 2), ('Dog', 3)],
    'Cat': [('runs', 1)],
    'Dog': [('runs', 2)],
    'runs': [('fast', 2)],
    'fast': []
}

graph1 = Graph(adjacency_list)
graph1.a_star_algorithm('The', 'fast')